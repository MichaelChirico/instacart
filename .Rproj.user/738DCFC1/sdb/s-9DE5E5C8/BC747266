{
    "collab_server" : "",
    "contents" : "as.data.table <-function(x, keep.rownames=FALSE, ...)\n{\n    if (is.null(x))\n        return(null.data.table())\n    UseMethod(\"as.data.table\")\n}\n\nas.data.table.default <- function(x, ...){\n  setDT(as.data.frame(x, ...))[]\n}\n\nas.data.table.factor <- as.data.table.ordered <- \nas.data.table.integer <- as.data.table.numeric <- \nas.data.table.logical <- as.data.table.character <- \nas.data.table.Date <- as.data.table.ITime <- function(x, keep.rownames=FALSE, ...) {\n    if (is.matrix(x)) {\n        return(as.data.table.matrix(x, ...))\n    }\n    tt = deparse(substitute(x))[1]\n    nm = names(x)\n    # FR #2356 - transfer names of named vector as \"rn\" column if required\n    if (!identical(keep.rownames, FALSE) & !is.null(nm)) \n        x <- list(nm, unname(x))\n    else x <- list(x)\n    if (tt == make.names(tt)) {\n        # can specify col name to keep.rownames, #575\n        nm = if (length(x) == 2L) if (is.character(keep.rownames)) keep.rownames[1L] else \"rn\"\n        setattr(x, 'names', c(nm, tt))\n    }\n    as.data.table.list(x, FALSE)\n}\n\n# as.data.table.table - FR #4848\nas.data.table.table <- function(x, keep.rownames=FALSE, ...) {\n    # Fix for bug #5408 - order of columns are different when doing as.data.table(with(DT, table(x, y)))\n    val = rev(dimnames(provideDimnames(x)))\n    if (is.null(names(val)) || !any(nzchar(names(val))))\n        setattr(val, 'names', paste(\"V\", rev(seq_along(val)), sep=\"\"))\n    ans <- data.table(do.call(CJ, c(val, sorted=FALSE)), N = as.vector(x))\n    setcolorder(ans, c(rev(head(names(ans), -1)), \"N\"))\n    ans\n}\n\nas.data.table.matrix <- function(x, keep.rownames=FALSE, ...) {\n    if (!identical(keep.rownames, FALSE)) {\n        # can specify col name to keep.rownames, #575\n        ans = data.table(rn=rownames(x), x, keep.rownames=FALSE)\n        if (is.character(keep.rownames))\n            setnames(ans, 'rn', keep.rownames[1L])\n        return(ans)\n    }\n    d <- dim(x)\n    nrows <- d[1L]\n    ir <- seq_len(nrows)\n    ncols <- d[2L]\n    ic <- seq_len(ncols)\n    dn <- dimnames(x)\n    collabs <- dn[[2L]]\n    empty <- !nzchar(collabs)\n    if (any(empty))\n        collabs[empty] <- paste(\"V\", ic, sep = \"\")[empty]\n    value <- vector(\"list\", ncols)\n    if (mode(x) == \"character\") {\n        # fix for #745 - A long overdue SO post: http://stackoverflow.com/questions/17691050/data-table-still-converts-strings-to-factors\n        for (i in ic) value[[i]] <- x[, i]                  # <strike>for efficiency.</strike> For consistency - data.table likes and prefers \"character\"\n    }\n    else {\n        for (i in ic) value[[i]] <- as.vector(x[, i])       # to drop any row.names that would otherwise be retained inside every column of the data.table\n    }\n    if (length(collabs) == ncols)\n        setattr(value, \"names\", collabs)\n    else\n        setattr(value, \"names\", paste(\"V\", ic, sep = \"\"))\n    setattr(value,\"row.names\",.set_row_names(nrows))\n    setattr(value,\"class\",c(\"data.table\",\"data.frame\"))\n    alloc.col(value)\n}\n\nas.data.table.list <- function(x, keep.rownames=FALSE, ...) {\n    if (!length(x)) return( null.data.table() )\n    # fix for #833, as.data.table.list with matrix/data.frame/data.table as a list element..\n    # TODO: move this entire logic (along with data.table() to C\n    for (i in seq_along(x)) {\n        dims = dim(x[[i]])\n        if (!is.null(dims)) {\n            ans = do.call(\"data.table\", x)\n            setnames(ans, make.unique(names(ans)))\n            return(ans)\n        }\n    }\n    n = vapply(x, length, 0L)\n    mn = max(n)\n    x = copy(x)\n    idx = which(n < mn)\n    if (length(idx)) {\n        for (i in idx) {\n            if (!is.null(x[[i]])) {# avoids warning when a list element is NULL\n                if (inherits(x[[i]], \"POSIXlt\")) {\n                    warning(\"POSIXlt column type detected and converted to POSIXct. We do not recommend use of POSIXlt at all because it uses 40 bytes to store one date.\")\n                    x[[i]] = as.POSIXct(x[[i]])\n                }\n                # Implementing FR #4813 - recycle with warning when nr %% nrows[i] != 0L\n                if (!n[i] && mn)\n                    warning(\"Item \", i, \" is of size 0 but maximum size is \", mn, \", therefore recycled with 'NA'\")\n                else if (n[i] && mn %% n[i] != 0)\n                    warning(\"Item \", i, \" is of size \", n[i], \" but maximum size is \", mn, \" (recycled leaving a remainder of \", mn%%n[i], \" items)\")\n                x[[i]] = rep(x[[i]], length.out=mn)\n            }\n        }\n    }\n    # fix for #842\n    if (mn > 0L) {\n        nz = which(n > 0L)\n        xx = point(vector(\"list\", length(nz)), seq_along(nz), x, nz)\n        if (!is.null(names(x)))\n            setattr(xx, 'names', names(x)[nz])\n        x = xx\n    }\n    if (is.null(names(x))) setattr(x,\"names\",paste(\"V\",seq_len(length(x)),sep=\"\"))\n    setattr(x,\"row.names\",.set_row_names(max(n)))\n    setattr(x,\"class\",c(\"data.table\",\"data.frame\"))\n    alloc.col(x)\n}\n\n# don't retain classes before \"data.frame\" while converting \n# from it.. like base R does. This'll break test #527 (see \n# tests and as.data.table.data.frame) I've commented #527 \n# for now. This addresses #1078 and #1128\n.resetclass <- function(x, class) {\n    cx = class(x)\n    n  = chmatch(class, cx)\n    cx = unique( c(\"data.table\", \"data.frame\", tail(cx, length(cx)-n)) )\n}\n\nas.data.table.data.frame <- function(x, keep.rownames=FALSE, ...) {\n    if (!identical(keep.rownames, FALSE)) {\n        # can specify col name to keep.rownames, #575\n        ans = data.table(rn=rownames(x), x, keep.rownames=FALSE)\n        if (is.character(keep.rownames))\n            setnames(ans, 'rn', keep.rownames[1L])\n        return(ans)\n    }\n    ans = copy(x)  # TO DO: change this deep copy to be shallow.\n    setattr(ans,\"row.names\",.set_row_names(nrow(x)))\n\n    ## NOTE: This test (#527) is no longer in effect ##\n    # for nlme::groupedData which has class c(\"nfnGroupedData\",\"nfGroupedData\",\"groupedData\",\"data.frame\")\n    # See test 527.\n    ## \n\n    # fix for #1078 and #1128, see .resetclass() for explanation.\n    setattr(ans, \"class\", .resetclass(x, \"data.frame\"))\n    alloc.col(ans)\n}\n\nas.data.table.data.table <- function(x, ...) {\n    # as.data.table always returns a copy, automatically takes care of #473\n    x = copy(x) # #1681\n    # fix for #1078 and #1128, see .resetclass() for explanation.\n    setattr(x, 'class', .resetclass(x, \"data.table\"))\n    return(x)\n}\n",
    "created" : 1495739719251.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2428467457",
    "id" : "BC747266",
    "lastKnownWriteTime" : 1495066004,
    "last_content_update" : 1495066004,
    "path" : "~/data.table/R/as.data.table.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}